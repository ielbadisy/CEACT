trt_grp <- data.frame(cost = rgamma(250, 1000), effect = runif(250, 1, 20), group = rep("treatment", 250))
control_grp <- data.frame(cost = rgamma(250, 10), effect = runif(250, 50, 100), group = rep("control", 250))
data <- rbind(trt_grp, control_grp)
ref <- 'control'
#'

# bootstrap the ratio of :
# Sepal.Length - Sepal.Width / Petal.Length - Petal.Width


#' Title
#'
#' @param x
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
summary.boot_icer <- function(x, ...){
  library(boot) # package for bootstrap
  ci.type = "bca"

  # check class
  return(x$estim_icer)
}
x <- c(0.02345,  0.03456,   0.04567)
y <- c(0.05432,  0.06543,   0.07654)

d <- data.frame(x, y)


round_df <- function(x, digits) {
  # round all numeric variables
  # x: data frame
  # digits: number of digits to round
  numeric_columns <- sapply(x, mode) == 'numeric'
  x[numeric_columns] <-  round(x[numeric_columns], digits)
  x
}

round_df(data, 1)


boot_icer <- function(cost, effect, group, ref, data, R = 999, ci.type = "bca", na.omit = TRUE, WTP){
  # set the order of variables
  #var_order <- c("cost", "effect", "group")
  # data <- data[, var_order]


  func <- function(data, i) {


    data <- data[i,]
    c(
      # 1 = cost ; 2 = effect

      mean_cost <- mean(data[data$group != ref, 1]) - mean(data[data$group == ref, 1]),
      mean_effect <- mean(data[data$group != ref, 2]) - mean(data[data$group == ref, 2]),
      icer <- (mean(data[data$group != ref, 1]) - mean(data[data$group == ref, 1])) / (mean(data[data$group != ref, 2]) - mean(data[data$group == ref, 2]))
    )
  }

  set.seed(1234)
  myboot <- boot(data, func, R = 1000)

  ci_estim_cost <- round(boot.ci(boot.out = myboot, type = ci.type, index = 1)$bca[4:5],3)
  ci_estim_effect <- round(boot.ci(boot.out = myboot, type = ci.type, index = 2)$bca[4:5],3)
  ci_estim_icer <- round(boot.ci(boot.out = myboot, type = ci.type, index = 3)$bca[4:5],3)

  boot_ce <- data.frame(boot_cost = myboot$t, boot_effect = myboot$t)


    estim_icer <- data.frame(
    Estimated = round(colMeans(myboot$t),3),
    Observed = round(myboot$t0,3),
    Std.Error = round(apply(myboot$t, 2, sd),3),
    Bias = round(colMeans(myboot$t) - myboot$t0, 3), #

    BCa.ci = c(paste('[',ci_estim_cost[1],';', ci_estim_cost[2],']'),
           paste('[', ci_estim_effect[1],';', ci_estim_effect[2], ']'),
           paste('[', ci_estim_icer[1],';', ci_estim_icer[2], ']')
    )

    )
    row.names(estim_icer) <- c("Mean Delta Cost", "Mean Delta Effect", "ICER")

    estim_icer <- round_df(estim_icer, 3)
    estim_icer <- tangram::tangram(estim_icer, id="tbl2", caption="Ordinary nonparametric bootstrap estmation of cost-effectiveness outcomes", style="nejm",  as.character=TRUE)
    res <- list(estim_icer=estim_icer, boot_ce = myboot$t[,1:2])
    class(res) <- "boot_icer"
    res


  #myboot$t # R values of our statistic generated by the bootstrap procedure
  #myboot$t0  # values of statistic in the original dataset
  #myboot # print results of boot object

  # biais = mean(myboot$t) - myboot$t0
  # std.error = standard error of bootstrap estimate (i.e. standard deviation of bootstrap realizations)

  # Different types of bootstrap CIs : norm, basic, stud, perc, bca see ?boot and type argument

  # if( plot = TRUE )
  # plot(myboot, index = 3)

  #=========================





}
x <- boot_icer(cost, effect, group, ref, data)


WTP <-csimdata$treshold = WTP * simdata$e

simdata$treshold_true <- simdata$treshold - simdata$cost

simdata$CE <- ifelse(simdata$treshold_true > 0, 1, 0)

simdata$CE_color <- ifelse(simdata$CE == 0, 2, 3)


WTP = 555

plot.boot_icer <- function(x){
  simdata <- data.frame(sim_c = x$boot_ce[,1], sim_e = x$boot_ce[,2])


  xlim <- ceiling(max(simdata$sim_e) * 1.2)
  ylim <- max(simdata$sim_e) * 1.2


  plot(simdata$sim_c ~ simdata$sim_e, cex=.8, #col=simdata$CE_col,
       pch=1,
       xlim=xlim, ylim=ylim)

  abline(h = 0, lwd=2 )
  abline(v=0, lwd=2 )

  abline(c(0,WTP),col = 4, lwd = 3)


}




